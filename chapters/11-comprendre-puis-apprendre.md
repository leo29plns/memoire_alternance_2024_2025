\newpage

# Comprendre puis apprendre, imiter et créer

## Comprendre le Design System

Après une longue semaine d'onboarding, je peux enfin me concentrer sur le travail en substance pour lequel j'ai été recruté. Mon équipe cherche alors dans le sprint en cours quel pourrait être le ticket me permettant de me familiariser avec le Design System. Un ticket a été désigné : _Import new icons_.

Ma toute première mission était donc simple : importer de nouvelles icônes au sein du Design System. En effet, le design system comporte toute une librairie d'icône réalisées par les designers. Parmi elles, on compte l'icône « panier d'achat », l'icône « valider », ou bien encore « supprimer ». Toutes ces icônes sont utilisables par le biais d'un composant nommé `<Icon />`.  
Le processus est donc simple : une fois les icônes crées dans le logiciel graphique Figma, il faut les exporter au format SVG, puis les renommer. Ensuite, elles doivent être ajoutées dans le _Repository_ du Design System, et listées. Je me lance donc dans cette première tâche avec l'aide d'Alexis.  
L'exécution se déroule sans trop d'encombre, et me voilà à créer ma première PR, ou _Pull Request_ dans GitHub. C'est l'étape par laquelle on soumet son travail à la révision. L'objectif est d'avoir un maximum de retours qui pourront, le cas échéant, déceler toutes les problématiques que le code soumis pourrait apporter, afin de les corriger. L'idée étant de _challenger_ le code : discuter de sa pertinence, de sa qualité, et des alternatives possibles.  
Ma première PR créée, et déjà des retours : ça ne va pas. Et pour cause : certaines icônes importées doivent comporter des jetons, ou _tokens_, de couleur. Ces jetons permettent à certaines parties de l'icône d'avoir une couleur définie en fonction du contexte de l'utilisation de l'icône. C'est une couleur variable qu'on peut changer après coup.  
Ce drôle d'incident met en évidence toute la complexité du Design System. Il illustre le désir de transposer une philosophie savamment réfléchie du Design System et transposée en code compréhensible par la machine. Le Design System, ce n'est pas juste la création de boutons et de menus déroulants, c'est la réflexion permettant un compromis lié au contexte d'utilisation du composant, à son intégration, et à l'expérience de l'utilisateur.

## Documenter pour autrui, mais surtout pour soi

Après quelques tickets passés à importer des icônes dans le Design System, me voilà fin prêt à passer un nouveau cap. Je vais faire ce que tout nouvel arrivant réalise dans son équipe : de la documentation. Si je dois être transparent, j'ai d'abord pensé que cette tâche serait simplement longue et rébarbative : sans plus de valeur ajoutée si ce n'est d'ancrer dans le marbre quelques informations déjà connues. Fort heureusement, je me trompais.  
La mission qui m'eut été donnée était la suivante : réaliser des exemples d'implémentation des composants de formulaire de notre Design System avec React Hook Form (RHF). Mais qu'est-ce que React Hook Form ?
RHF est une libraire complémentaire à React permettant de gérer plus facilement des formulaires. En effet, un formulaire pourrait-être géré nativement par le navigateur, mais avec React et son système de DOM virtuel[^dom-virtuel] les choses deviennent moins aisées. Il faut collecter les entrées de l'utilisateur, valider les informations saisies, parfois assembler des morceaux de formulaire issus de pages différentes pour améliorer l'expérience utilisateur, et tant d'autres. Pour résumer, RHF simplifie l'intégration de formulaires avec React.  
En travaillant ce ticket, j'ai appris énormément de choses. D'abord, sur le fonctionnement interne de nos composants. Cela peut paraître anodin, mais il y a une certaine frontière entre survoler du code, et penser le comprendre, et réellement l'implémenter, l'utiliser. Cette expérience m'a permis de découvrir les rouages internes à notre Design System, et de tester nos composants dans un environnement _sandboxé_ : la _Sample App_.  
Par-delà l'apprentissage du fonctionnement de nos propres composants, j'ai aussi appris à rédiger pour autrui, en anglais. La tâche n'est pas simple, il faut placer le curseur entre détail et simplification : ne pas écrire trop pour être lu, sans manquer d'information pour utiliser pleinement le composant.  
Enfin, un apprentissage important que je tire de ce ticket : il ne faut pas prendre les choses pour acquises. Je pensais, à tort, que les développeurs qui allaient utiliser nos composants, consommer notre Design System, sauraient comment utiliser RHF. Pour moi il n'y avait pas d'utilité à documenter ce qui relevait de l'évidence. Et pourtant, une des tâches du Design System est d'uniformiser l'usage. Il y avait donc une réelle valeur ajoutée à cette mission.

## Comprendre pour améliorer

Une étape importante dans l'évolution de mes tâches au sein du Design System aura été d'améliorer les composants alors en place.  
En effet, ce fut ma première occasion de modifier du code React dans le _repo_. Cette action est loin d'être insignifiante : je dois modifier un code existant et fonctionnel, qui est en production, et utiliser à de multiples endroits auprès de notre _consumer_. Il faut comprendre l'existant, ne pas casser la logique en place, et ne pas réinventer la roue. En effet, ce composant existe dans un contexte : celui du Design System tout entier. Alors, pour conserver une certaine homogénéité, il faut s'inspirer des mécanismes déjà en place, comme le méthode de nommage des classes CSS, la manière dont sont gérés les IDs, les variants, etc.  
Je réalisais alors ma première amélioration de l'existant avec le composant `<FilterGroup />`.

<!-- TODO: ajouter une image -->
Le composant `<FilterGroup />` est un élément de formulaire permettant de faire une sélection. _Sous le capot_, autrement dit, dans sa construction interne, le `<FilterGroup />` utilise les éléments HTML natifs suivants :

- `<input type="checkbox">`quand la sélection est un choix multiple, que l'on peut sélectionner plusieurs valeurs à a fois ;
- `<input type="radio">` quand notre sélection n'autorise qu'une seule réponse.

Cette utilisation d'éléments natifs s'inscrit pleinement dans la philosophie assumée du Design System : reposer le plus possible sur des standards du web, et les méthodes natives aux navigateurs. Ce choix s'explique notamment par le fait qu'il existe une diversité de navigateurs qui est telle, que d'adapter une logique fonctionnelle à l'ensemble des navigateurs serait une tâche chronophage.  
Pourtant, il y a un point sur lequel tous les navigateurs doivent se rejoindre : les standards établis par le W3C, ou _World Wide Web Consortium_. Par groupes de travail, le W3C cherche à standardiser, unifier, créer une source de vérité unique que les navigateurs devront implémenter. Ce rôle était essentiel, surtout à la genèse du web : pouvoir discuter le même langage entre clients et serveurs, tout en proposant une évolution continue des standards.  
Reposer sur les règles du W3C, et donc sur les méthodes d'un navigateur, permet d'accroître la pérennité d'une implémentation réalisée. De plus, c'est s'affranchir d'une étape de réflexion complexe pour penser à l'ensemble des cas d'usage, pour prévoir par exemple l'accessibilité. Le W3C, à travers les WCAG, ou _Web Content Accessibility Guidelines_ adapte déjà ses règles pour qu'elles soient conformes à un certain niveau d'exigence en matière d'accessibilité numérique. En outre, reposer sur natif, c'est pérenniser, alléger la dette technique, mais aussi faire le choix d'une accessibilité établie, réfléchie.

Quelles sont les étapes du processus d'amélioration d'un composant ? Prenons l'exemple du `<FilterGroup />`. Au tout départ, il faut déjà exprimer, comprendre un besoin. La demande peut être extérieure au Design System : un _consumer_ peut avoir besoin de modifier un comportement du composant, ou interne au Design System.  
Après coup, si l'idée est retenue, elle va devoir passer une validation importante, ayant lieu dès le design. Est-ce que cette amélioration est conforme aux valeurs et à la philosophie du Design System ? Par exemple, est-elle suffisamment générique ? Si le besoin dépasse le cas isolé, et que la fonctionnalité a bien sa place dans le Design System, alors une première étape de design est lancée, sous la responsabilité de Betty. Toujours avec le `<FilterGroup />`, l'une des propositions d'amélioration était de rajouter des variants de taille pour le composant. Rajouter une taille `s` et une taille `l`.

Une fois le composant designé, vient l'étape d'intégration dans le _repo_. C'est à cette étape que j'interviens. Après avoir ouvert le design sur Figma, je dis analyser le composant, le comprendre dans le moindre détail. Aussi, je dois comprendre ce qui était, pour comprendre les évolutions et les amélioration apportés au composant. Par exemple, déceler quels sont les _tokens_ pour les `border-radiuses`, pour la couleur de fond, pour la taille des bords, les espaces, la taille des textes, et tant d'autres.  
Après cela vient le code. Notre approche par le _Test Driven Development_ nous pousse à concevoir en premier lieu les tests unitaires, ceux qui vont tester la logique interne du composant. Par exemple, ici, je devais créer un test pour m'assurer que le composant recevait bel et bien les classes CSS correspondantes au variant de taille sélectionné, parmi `s`, `m` et `l`.  
Ensuite, il faut adapter la logique dans le fichier de déclaration React. Ajouter un système permettant de choisir un variant grâce à une _props_, et ajouter cette nouvelle caractéristique à l'interface TypeScript du composant. Il faut ajuster en conséquence le fichier CSS, permettant d'appliquer à une classe donnée, les _tokens_ donnés. Par exemple : 

```css
.watts-filter-group {
    display: flex;
    
    &--s {
    	gap: var(--watts-spacing-025);
    }
    
    ...
}
```

Une fois cette étape réalisée, il ne reste plus que quelques étapes. Il faut d'abord ajuster les _stories_ de StoryBook, afin que le composant soit illustré de manière interactive, présenté en démonstration, pour nous et nos _consumers_. Il faut également ajouter une story Percy pour les test visuels. Et enfin, après avoir révisé l'ensemble du code, il faut le soumettre à la révision des pairs par le biais d'une _Pull Request_ sur GitHub.

## Accompagner dans l'usage

Dans le développement web, il y a toutes ces missions auxquelles on pense, développement de code et revue, React, tests unitaires, etc. Mais il y a aussi toutes ces choses qui ne viennent pas directement à l'esprit. L'une d'elles : le support technique pour nos _consumers_. Malgré avoir documenté nos composants, de proposer différents outils pour aider dans l'utilisation de nos composants, mais également en ayant adopté une conception détachée du consommateur final, nous devons tout de même être à l'écoute des retours.

Ces retours prennent forme dans ce qu'on appelle un _channel_ Teams. Il s'agit d'un groupe de discussion où les utilisateurs de Watts peuvent laisser un message, souvent dans l'attente d'un retour de notre équipe. Il s'agit s'agit de la Hotline Watts.  
Ces retours peuvent être distingués en trois catégories : les vrais bugs, les faux bugs, et les demandes d'amélioration.

Tout système logiciel comporte un défaut de fonctionnement n'ayant pas été prévu à l'origine. On ne peut pas l'éviter. Même les libraires écrites en langage bas niveau laissent apparaître quelques bugs, plus ou moins critiques. Notre Design System Watts ne fait donc pas exception. Mais pour cela, il faut être à l'écouter des personnes qui utilisent notre Design System, pour déceler au plus tôt le moindre bug. C'est la loi dite de Linus « _given enough eyeballs, all bugs are shallow_ ». Autrement dit, plus un logiciel est utilisé et relu par des yeux différents, plus on découvre rapidement les défauts, devenant ainsi faciles à corriger.  
C'est pourquoi il est important de répondre activement aux messages laissés dans la Hotline, permettant de garder un contact constant avec nos _consumers_, et de relever le moindre bug provenant de notre librairie.

Mais il arrive parfois de croiser dans la Hotline ce qu'on appelle de faux bugs, ou dit autrement, des faux-positifs. Ces bugs ne proviennent en réalité pas du code produit par Watts, mais d'une erreur d'implémentation. L'utilisateur implémentant le Design System n'a pas utilisé comme il aurait dû l'un de nos composants. Est-ce de sa faute pour autant ? C'est là le principe de remise en question qu'il faut avoir. Premièrement : est-ce que le bug ne viendrait pas de Watts ? Aussi, s'il y a effectivement eu erreur d'implémentation, avons-nous correctement documenté, expliqué, la manière dont il faut utiliser nos composants. Parfois, cette introspection pousse même à revoir la manière dont nous avons conçu les composants.  
Si effectivement le problème vient bien de l'utilisateur, que notre remise en question ne permet pas de remettre en cause notre Design System, alors il nous faut accompagner le _consumer_ pour l'aider au mieux à intégrer nos composants.  
Cette démarche peut paraître étrange : le Design System qui n'est pas censé s'adapter directement à la manière dont il est utilisé. Pourtant, Watts n'est pas dans un Design System publique, il évolue dans un environnement particulier. Watts est soumis aux enjeux de l'entreprise qu'est Sonepar. On ne peut donc pas se permettre de faire une totale abstraction de l'utilisateur : cela irait à l'encontre des logiques de délivrabilité, et par extension, de rentabilité de l'entreprise.

Enfin, il y a les demandes d'amélioration. Là aussi, il faut faire preuve d'ouverture. Il faut concilier la philosophie et les principes fondateurs du Design System, tout en accueillant cette nouvelle demande. Est alors repris un concept d'expérience utilisateur : la demande exprimée par l'utilisateur répond-elle à son besoin ?  
Une phrase que l'on attribue à Henri [Ford]{.smallcaps} est la suivante : «_If I had asked people what they wanted, they would have said faster horses._ ». Les utilisateurs expriment souvent leur besoin par des solutions, sans réellement comprendre le besoin intrinsèque. Ici, les utilisateurs n'avait pas besoin de chevaux plus rapides, mais d'une voiture. Le besoin n'était pas d'aller plus vite, le besoin était de se déplacer plus vite et plus efficacement.  
Et bien c'est ce même exercice auquel notre équipe doit se livrer lors de la suggestion d'une amélioration. À date, notre Design System encourage même les développeurs à challenger les designers lorsqu'ils se retrouvent face à une difficulté technique. Était-ce réellement la bonne chose à utiliser ? Un exemple pourrait être un utilisateur qui demande une nouvelle fonctionnalité dans le composant `<Radio />` : pouvoir cocher plusieurs options en même temps. La solution n'est pas d'implémenter cette fonctionnalité, mais de challenger le besoin, pour finalement comprendre que l'utilisateur devait utiliser un composant `<Checkbox />` dont c'est le comportement par défaut.

## Créer des composants agnostiques

Le Design System Watts est introverti et indépendant. Watts n'aime pas savoir comment il est utilisé, et ne veut pas s'adapter aux autres. Pour reformuler, une caractéristique majeure de notre Design System est de le rendre agnostique. La définition française du terme « agnostique » n'est pas fidèle à son faux-ami outre-atlantique. L'idée de web agnostique apparaît sous une certaine forme de neutralité et d'indépendance à l'extérieure.  
Concrètement, il s'agit de ne pas être dépendant d'une quelconque technologie, pour pouvoir s'adapter à toutes. C'est un peu la même histoire avec l'USB-C : essayer de s'adapter à tous les périphériques, plutôt que de créer un connecteur pour chaque appareil.

Au sein de Watts, l'un des premiers choix techniques fut de réaliser, coder nos composants avec React. React étant la solution la plus simple, la plus répandue, et la plus robuste. C'est un choix par défaut qui fait l'unanimité dans les entreprises.  
Pourtant, ce choix a été remis en question il y près d'un an. En effet : en utilisant react dans notre Design System, on force nos utilisateurs à utiliser React. Et malgré le consensus établi autour de cette technologie, les voix montent pour contester l'hégémonie de librairie créée par Facebook. En ce sens : comment donner du poids à ces contestations, comment expérimenter, si nos choix techniques contraignent à l'utilisation d'une technologie donnée ?

Ainsi, il été fait le choix de créer une seconde libraire de composants, mais avec des composants un peu particuliers : les web components.  
Les web components sont relativement vieux à l'échelle d'internet. En 2011 déjà, Alex [Russell]{.smallcaps} présentait son idée de web components à la Fronteers Conference. De la simple idée est alors née un projet. Pourtant, ce projet a mis du temps pour se concrétiser. Les standards du web évoluent très lentement, et c'est d'ailleurs ce qui en fait l'une de leurs principales qualités, mais est aussi un frein à l'innovation. Aussi stables que les règles du W3C soient, elles sont égalements lentes pour évoluer. En plus de cela, le W3C n'est qu'une première étape, pour ensuite attendre une implémentation du côté des navigateurs. Il suffit de regarder depuis quand existent les spécification du sélecteur CSS `:has` (2013) et de la date de son implémentation officielle dans Firefox (2023).  
Ce délai s'étire davantage pour les web components : les implémentation et les spécifications ne sont toujours pas stables. Même s'il existe un support officiel sur tous les principaux navigateurs depuis 2018, certaines fonctionnalités majeures ne sont pas encore disponibles. Cela n'a pas empêcher des équipes, comme celles de Carbon Design System (IBM), ou Fluent (Microsoft) à adopter les web components dans leurs libraires de composants. Et c'est dans cette lignée que s'inscrit la volonté de watts de créer des web components.

Mais au fait, qu'est-ce que des web components ? Les web components sont natifs aux navigateurs : ils fonctionnent sans librairie externe, et permettent de créer des composants réactifs, réutilisables, et isolés du reste de la page.  
On peut les comparer aux composants React, qui sont eux aussi encapsulés et réutilisables, mais nécessitent l’écosystème React pour fonctionner. Les web components, eux, peuvent s’insérer partout, permettant réactivité et encapsulation sans imposer un choix technique, faisant d'eux des candidats idéal pour un Design System agnostique. Pourtant, ils introduisent une philosophie quelque peu différente des composants react, notamment de leur principe d'isolation, qui sera un défi pour notre équipe.

Et c'est ainsi que j'ai eu l'honneur de travailler à la création de web components pour Watts. L'idée était simple : nous avons un existant en React, et il faut le reproduire le plus fidèlement possible en web components.  
Pour cela, l'équipe avait créé un planning détaillé de l'ordre dans lequel les composants devaient être créés. Grâce à l'expérience acquise avec les React, il était plus simple d'identifier les dépendances entre chaque composant. Par exemple, le composant `<watts-menu></watts-menu>` a lui-même besoin du composant `<watts-button></watts-button>`, intégrant à son tour le composant `<watts-icon></watts-icon>`. C'est enchevêtrement complexe de composants.

Une fois une roadmap établie, il faut ensuite développer, coder les composants. Cette étape n'a pas été simple pour moi, et cela s'explique. Je suis arrivé aux quasi-prémices des Watts web components. Cela implique un faible nombre de composants existants, seulement trois quand j'étais arrivé. Ces trois composants ne peuvent pas refléter l'ensemble des logiques à intégrer dans chaque composant. Je devais donc constamment me renseigner, benchmarquer, pour essayer d'intégrer la solution la plus adéquate, et faisant consensus. Mais comme expliqué précédemment, l'écosystème des web components n'est pas encore tout à fait mature : les exemples manquent, et certaines fonctionnalités ne sont pas encore disponibles.

Il faut alors faire preuve d'originalité et faire des compromis : créer des fonctions de toutes pièces, accepter une différence de fonctionnement avec les composants React.  
L'illustration parfaite est avec le dernier web component sur lequel j'ai travaillé : le bouton radio. Du fait de l'imbrication des web components, et leur principe d'isolation, il était impossible de faire communiquer ces éléments. Là où un bouton radio ne permet de sélectionner qu'une seule option, mon web component permettait de toutes les sélectionner. Alors, nous avons dû faire le choix de créer un composant parent, le `<watts-radio-group></watts-radio-group>`. Ce composant n'a que pour seule fonction de regrouper les `<watts-radio></watts-radio>`, et d’imiter le comportement natif du navigateur avec les input radio : n'avoir qu'une seule option sélectionnée à la fois.

## La mère de toutes mes démos

Imaginez, un alternant à l'expérience professionnelle sans précédent, et à l'anglais balbutiant. Nous étions au tout début de mon alternance, ou presque. J'avais passé à peine plus de deux semaines avec mon équipe. Et voilà que Betty déclare devant l'équipe : « pourquoi Léo tu ne présenterais donc pas ton travail lors de la démo ? ». C'était la pire chose que l'on puisse me proposer.

Les démos font partie des rituels SAFe. La démo est à réaliser une fois par sprint, à la fin de ce dernier. L'idée est très simple : mettre en avant le travail effectué pour montrer aux autres équipes notre travail. Cela permet de montrer une progression, de mettre à jour certaines synchronisations entre les équipes, de soulever les questions s'il y en a, et de comprendre ce que les autres font. C'est pour cela qu'une journée entière est réservée à ces démos.  
Ainsi, le jour qui précède la fin du sprint est alloué aux démos. Celles-ci sont relativement courtes, elles durent 15 minutes, et ne sont que très peu mises en forme. Ce n'est pas une présentation officielle, c'est un rituel SAFe.

Concrètement, ces _meetings_ se déroulent en anglais. Ils ont lieu l'après-midi, en France, pour que le plus grand nombre de nos collaborateurs puissent participer, qu'ils soient outre-atlantique, ou en asie du sud. Avant chaque démo, des membres de l'équipe sont désignés pour présenter leur travail. Ils doivent expliquer succinctement le travail qu'ils ont réalisé (correction de bug, création de feature, etc.), et présenter idéalement une demonstration de leur travail, à travers un partage d'écran.

Quand Betty m'a proposé cet exercice pour la première fois, je ne voulais pas. C'est une d'anxiété qui dépassait mon entendement. Je suis timide, je ne suis pas à l'aise à l'oral sans longue préparation, et j'ai honte de mon anglais. Mais ma timidité était telle, que je n'ai pas pu refuser. Après tout, c'est mon travail, je dois assumer cette tâche. 

Ce n’est pas sans une certaine réticence que je commençais donc à préparer ma présentation, la boule au ventre. Je m'aidais alors de ChatGPT avec des prompts comme « Aide-moi à traduire cette phrase dans un anglais courant, de l'oral, fluide et naturel ». J'imprimais même mon texte, pour être sûr de l'avoir devant les yeux tout en partageant mon écran.  
D'ailleurs, pour éviter l'effet démo, à savoir une démonstration qui rencontre un bug technique, je réalisais alors une présentation sous forme de _slides_ pour montrer des captures d'écran où tout fonctionne. 

Le moment tant redouté arrive. Mon cœur semble vouloir se détacher de ma poitrine, j'ai les mains qui tremble, un teint anormal. Carla, présentatrice de notre démo, m'introduit alors. Après un court temps d'hésitation, je commençais à m'exprimer. Le temps s'était allongé, étiré, chacun de mes mots semblait durer une éternité, en plus d'être écorchés par mon accent... relatif.  
Pourtant, quelle ne fut pas ma surprise de voir tous ces sourires à la fin de ma présentation. Ce que j'oubliais, c'est que j'avais face à moi des êtres humains. Qu'ils viennent des États-Unis, ou bien d'inde, ils ont un cœur ! Et ils savaient que c'était ma toute première présentation.  
Finalement, cette première présentation a été très bien accueillie, j'ai même été félicité. Si on fait preuve de lucidité, cette présentation était imparfaite, des mots me manquaient, d'autres étaient mal prononcés, mais le message était passé. En fait, il faut voir le verre à moitié plein : cette présentation à le potentiel d'être améliorée ! Et c'est même le propre pour le travail d'un alternant. Il jouit d'un statut particulier : l'alternant n'a que peu d'expérience. Il se forme au travers de ses cours et de ses premières expériences professionnelles : il apprend.  
J'ai eu la chance d'avoir face à moi des personnes bienveillantes, qui m'ont encouragé, et qui ont été attentives et compréhensives lors de cette démo.

Le temps a passé, et j'ai pu réaliser de nombreuses autres démos, essayant de me détacher de mes notes, d'être plus spontané, d'améliorer ma prononciation, et surtout, de me porter volontaire pour présenter mon travail. Je dois l'avouer, j'avais même plaisir à réaliser cet exercice lors des derniers mois.

Finalement, pourquoi est-ce que je ne présenterai pas mon travail lors de la démo ? Cette invitation a permis de me lancer, d'oser, de me tromper et de m'améliorer. Briser mes habitudes, m'ouvrir aux autres, pratiquer mon anglais, et vaincre ma peur. C'était la meilleure chose que l'on m'ait proposé. 

## Vers l'évolution du Design System

En somme, j'ai pu réaliser de nombreuses missions au sein de mon équipe Watts, entre documentation et support technique, amélioration de composants existants, et création de nouveaux mécanismes. Pourtant il y une tâche que l'on peut difficilement mesurer, et qui a pourtant été la plus enrichissante pour moi : faire preuve d'initiative, et encourager l'innovation.

En effet, il y a dans tout travail une ambivalence du métier. Se contenter de faire ce qui nous est demandé, mais il y aussi le fait d'aller au-delà. Et je me suis essayé à cela. Mais comment passer outre ? Et bien tout simplement en proposant des améliorations. Mais il y a une chose qu'il faut prendre en compte : avoir le bon état d'esprit.

Quand je suis arrivé dans l'équipe, je dévaluais à bien des égards mon niveau. Peut-être même, avais-je là le syndrome de l'imposteur. Peut-importe le terme pour le définir, à ce moment précis, je considérais mes connaissances comme quasi-nulles, mettant sur un piédestal mes collègues. En effet, quand on se met à travailler avec des personnes qui ont acquis une certaine expérience professionnelle, à travers les entreprises et les années, on présent que notre maigre expérience aurait bien de la peine à s'imposer. De même, leur parcours universitaire démontre à nouveau une supériorité technique, laissant sans-voix la mienne.  
Pourtant, il m'aura fallu du temps pour comprendre que ce n'est pas parce que mon expérience et mes connaissances sont moindres que je ne peux rien apporter. Et au contraire : le web est en constante mouvance. Il suffit de voir comme il a évolué à travers les années pour comprendre que ce qui était valable hier, ne l'est peut-être plus aujourd'hui. Et c'est cette mouvance qui permet aux développeur juniors d'avoir un regard neuf sur le web.  
C'est en comprenant cela que j'ai réalisé que mes idées pouvaient faire sens et qu'elles pouvaient être légitimes.

Je me souviens avoir suggéré à Mélanie une amélioration dans le Design System, et à la manière dont on gérait le fonctionnement du bouton dans le composant `<Menu />`. Sous couvert d'euphémismes, je présentais alors mon idée, pour aborder la problématique autrement. Je découvrais alors avec surprise la réaction de Mélanie, qui en plus de prendre avec sérieux ma suggestion, me complimentait pour avoir fait cette proposition.  
Je réalisais alors que je pouvais moi aussi apporter à mon échelle, contribuer au Design System, en apportant un regard alternatif du fait de mon expérience. C'est un regard complémentaire à celui de la _seniorité_ de mes collègues.
